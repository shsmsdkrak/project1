클래스
	- 객체의 설계도이다.
	- 클래스를 이용하는 것은 객체지향프로그래밍을 하는것이다.
	- 객체의 기능을 설계도화 하기위해서는 객체의 기능을 잘모아두어야 하는데 이를 캡슐화라고 한다.
	- 객체와 관련 된 데이터, 기능을 한데 모아두는 것을 말한다.

인터페이스
	- 인터페이스란 상속관계가 아닌 클래스에(추상클래스처럼) 기능을 제공하는 구조이다.
	- 클래스와 비슷한 구조이지만, 정의와 추상 메서드만이 멤버가 될 수 있다는 점이 다르다.
	- 클래스에서 인터페이스를 이용하도록 하게 하는 것을 "인터페이스의 구현"이라고 한다.
	- 인터페이스를 구현하기 위해서는 implements(클래스는 extends)를 사용한다.
	- 인터페이스는 다중상속이 가능하다. (클래스는 단일 상속만 가능)
	- 클래스와 동일하게 인터페이스간에 상속도 가능하다. (다중 인터페이스 상속도 가능)

다형성
	- 서브 클래스의 오브젝트는 슈퍼 클래스의 오브젝트에 대입할 수 있다.
	- 상속한 클래스의 오브젝트는 슈퍼 클래스로도 서브 클래스로도 다룰 수 있다.
	- 하나의 오브젝트와 메서드가 많은 형태를 가지고 있는 것을 다형성이라고 한다.
	- 상위클래스의 객체를 하위클래스의 객체로 대입할 수는 없다.

계층구조가 필요할 때 - 클래스 사용
단순 기능만 제공해야할 때 - 인터페이스 사용

디자인패턴적인 의미에서는 추상클래스를 사용하기보단, 인터페이스를 사용하는것을 권장함.

은닉화
	- 객체의 변수를 public으로 설정하면, 외부에서 마음대로 이 변수를 사용할 수 있다.
	- 의도하지 않은 범위의 값을 넣을 수 있다.
	- 원하지 않는 데이터타입을 강제적으로 형변환하여 넣을 수도 있다. ex) -10살, 이름 "32"
	- 은닉화 된 데이터를 가공하기 위해서는 setter, getter를 사용하여야 한다. private에 접근할 수 없기 때문

절차지향 및 객체지향
	- 절차지향 프로그래밍
		- 사용언어 : C
		- 방식 : 차체 > 바퀴 > 엔진 > 핸들 순으로 작업 - 순서가 바뀌면 안됨.
		- 절차지향 프로그래밍은 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.
		- 여러함수가 데이터를 주고 받으며, 데이터를 공유하는 순서가 존재한다.
		- 서로 분리되면 안되고 함수호출 순서가 틀려서도 안되며, 하나가 고장나면 전체기능이 마비된다.
		- 절차지향은 데이터를 중심으로 함수를 구성한다. 함수의 호출 순서가 바뀌면 데이터의 전달과 값이 변할 수 있다.

	- 객체지향 프로그래밍
		- 사용언어 : Java, C#, C++, Python, JavaScript.. 등
		- 방식 : 각 요소를 외부에서 만들어와서 조립한다. - 순서가 바뀌어도 상관없다.
		- 객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화를 하고, 모듈을 재활용하는 프로그래밍 기법이다.
		- 제작에 있어서 순서적이지 않아도 된다.
		- 각각 따로 독립적으로 개발되어 나중에 한곳에 모여 자신의 기능만 제대로 발휘하면 된다.
		- 부품들이 결합되어 움직이다 어느 하나가 고장이 나면 고장난 부품만 고쳐주면 되고, 다른 부품들은 영향을 받지 않는다.
		- 필요하면 부품을 다른 것으로 교체할 수 있다.

===========================================================================================================================

객체지향과 비용
- 비용을 낮추는 방법 : 캡슐화 + 다형성(추상화)

객체
- 절차지향
	- 데이터를 여러 프로시저가 공유하고있는 것
	- 처음에는 사용하기가 쉽다.
	- 시간이 흐름에 따라 유지보수가 어렵다.
- 객체지향
	- 데이터와 프로시저를 객체라는 공간에 담는다.
	- 처음에는 사용하기 어렵다.
	- 시간이 흐름에 따라 유지보수가 쉽다.
- 객체란?
	- 객체의 핵심 > 기능제공
		ㄴ 내부적으로 가진 필드(데이터)로 정의하지 않음
		ex) 회원 객체 - 암호 변경, 차단여부 확인 등등..
		ex) 소리제어 객체 - 소리크기 증가, 소리크기 감소 등등..
	- 기능명세
		ㄴ 메서드(오퍼레이션)를 이용해서 기능 명세 - 이름, 파라미터, 결과로 구성
	- 객체와 객체
		ㄴ 객체와 겍체는 기능을 사용(메서드 호출)해서 연결
		ㄴ 객체와 객체가 상호 작용 - 메세지를 주고 받는다고 표현
캡슐화
	- 데이터 + 관련 기능 묶기
	- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
		ㄴ 구현에 사용 된 데이터의 상세 내용을 외부에 감춤
	- 정보은닉(Information Hiding)의미 포함
	- 외부에 영향 없이 객체 내부 구현 변경 가능
	- 외부에서 사용하는 기능은 그대로, 내부에서의 로직만 변경 > 캡슐화를 하는 이유(관리 포인트가 적어진다)
	- 캡슐화와 기능
		ㄴ 캡슐화 시도 > 기능에 대한(의도) 이해를 높임
	- 캡슐화를 위한 규칙
		ㄴ Tell, Don't Ask
			- 데이터를 달라 하지 말고 해달라고 하기
				ex) if(a.getADat()){...} === "A" >> id(a.hasDataAdata()){...}
		ㄴ Demeter's Law
			- 메서드에서 생성한 객체의 메서드만 호출
			- 파라미터로 받은 객체의 메서드만 호출
			- 속성으로 참조하는 객체의 메서드만 호출
	- 정리
		ㄴ 기능의 구현을 외부에 감춤
		ㄴ 캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고(또는 최소화) 내부 구현을 변경할 수 있는 유연함
	- 캡슐화 연습
		ㄴ 데이터를 가져와서 비교하고, 그 비교한 값으로 데이터를 변경할 때는 통째로 캡슐화 시도
		ㄴ 데이터를 직접 가져와서 변경하는 부분은 로직을 내부적 캡슐화 하여 처리한다.