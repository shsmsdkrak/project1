클래스
	- 객체의 설계도이다.
	- 클래스를 이용하는 것은 객체지향프로그래밍을 하는것이다.
	- 객체의 기능을 설계도화 하기위해서는 객체의 기능을 잘모아두어야 하는데 이를 캡슐화라고 한다.
	- 객체와 관련 된 데이터, 기능을 한데 모아두는 것을 말한다.

인터페이스
	- 인터페이스란 상속관계가 아닌 클래스에(추상클래스처럼) 기능을 제공하는 구조이다.
	- 클래스와 비슷한 구조이지만, 정의와 추상 메서드만이 멤버가 될 수 있다는 점이 다르다.
	- 클래스에서 인터페이스를 이용하도록 하게 하는 것을 "인터페이스의 구현"이라고 한다.
	- 인터페이스를 구현하기 위해서는 implements(클래스는 extends)를 사용한다.
	- 인터페이스는 다중상속이 가능하다. (클래스는 단일 상속만 가능)
	- 클래스와 동일하게 인터페이스간에 상속도 가능하다. (다중 인터페이스 상속도 가능)

다형성
	- 서브 클래스의 오브젝트는 슈퍼 클래스의 오브젝트에 대입할 수 있다.
	- 상속한 클래스의 오브젝트는 슈퍼 클래스로도 서브 클래스로도 다룰 수 있다.
	- 하나의 오브젝트와 메서드가 많은 형태를 가지고 있는 것을 다형성이라고 한다.
	- 상위클래스의 객체를 하위클래스의 객체로 대입할 수는 없다.

계층구조가 필요할 때 - 클래스 사용
단순 기능만 제공해야할 때 - 인터페이스 사용

디자인패턴적인 의미에서는 추상클래스를 사용하기보단, 인터페이스를 사용하는것을 권장함.

은닉화
	- 객체의 변수를 public으로 설정하면, 외부에서 마음대로 이 변수를 사용할 수 있다.
	- 의도하지 않은 범위의 값을 넣을 수 있다.
	- 원하지 않는 데이터타입을 강제적으로 형변환하여 넣을 수도 있다. ex) -10살, 이름 "32"
	- 은닉화 된 데이터를 가공하기 위해서는 setter, getter를 사용하여야 한다. private에 접근할 수 없기 때문

절차지향 및 객체지향
	- 절차지향 프로그래밍
		- 사용언어 : C
		- 방식 : 차체 > 바퀴 > 엔진 > 핸들 순으로 작업 - 순서가 바뀌면 안됨.
		- 절차지향 프로그래밍은 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.
		- 여러함수가 데이터를 주고 받으며, 데이터를 공유하는 순서가 존재한다.
		- 서로 분리되면 안되고 함수호출 순서가 틀려서도 안되며, 하나가 고장나면 전체기능이 마비된다.
		- 절차지향은 데이터를 중심으로 함수를 구성한다. 함수의 호출 순서가 바뀌면 데이터의 전달과 값이 변할 수 있다.

	- 객체지향 프로그래밍
		- 사용언어 : Java, C#, C++, Python, JavaScript.. 등
		- 방식 : 각 요소를 외부에서 만들어와서 조립한다. - 순서가 바뀌어도 상관없다.
		- 객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화를 하고, 모듈을 재활용하는 프로그래밍 기법이다.
		- 제작에 있어서 순서적이지 않아도 된다.
		- 각각 따로 독립적으로 개발되어 나중에 한곳에 모여 자신의 기능만 제대로 발휘하면 된다.
		- 부품들이 결합되어 움직이다 어느 하나가 고장이 나면 고장난 부품만 고쳐주면 되고, 다른 부품들은 영향을 받지 않는다.
		- 필요하면 부품을 다른 것으로 교체할 수 있다.

===========================================================================================================================

객체지향과 비용
- 비용을 낮추는 방법 : 캡슐화 + 다형성(추상화)

객체
- 절차지향
	- 데이터를 여러 프로시저가 공유하고있는 것
	- 처음에는 사용하기가 쉽다.
	- 시간이 흐름에 따라 유지보수가 어렵다.
- 객체지향
	- 데이터와 프로시저를 객체라는 공간에 담는다.
	- 처음에는 사용하기 어렵다.
	- 시간이 흐름에 따라 유지보수가 쉽다.
- 객체란?
	- 객체의 핵심 > 기능제공
		ㄴ 내부적으로 가진 필드(데이터)로 정의하지 않음
		ex) 회원 객체 - 암호 변경, 차단여부 확인 등등..
		ex) 소리제어 객체 - 소리크기 증가, 소리크기 감소 등등..
	- 기능명세
		ㄴ 메서드(오퍼레이션)를 이용해서 기능 명세 - 이름, 파라미터, 결과로 구성
	- 객체와 객체
		ㄴ 객체와 겍체는 기능을 사용(메서드 호출)해서 연결
		ㄴ 객체와 객체가 상호 작용 - 메세지를 주고 받는다고 표현
캡슐화
	- 데이터 + 관련 기능 묶기
	- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
		ㄴ 구현에 사용 된 데이터의 상세 내용을 외부에 감춤
	- 정보은닉(Information Hiding)의미 포함
	- 외부에 영향 없이 객체 내부 구현 변경 가능
	- 외부에서 사용하는 기능은 그대로, 내부에서의 로직만 변경 > 캡슐화를 하는 이유(관리 포인트가 적어진다)
	- 캡슐화와 기능
		ㄴ 캡슐화 시도 > 기능에 대한(의도) 이해를 높임
	- 캡슐화를 위한 규칙
		ㄴ Tell, Don't Ask
			- 데이터를 달라 하지 말고 해달라고 하기
				ex) if(a.getADat()){...} === "A" >> id(a.hasDataAdata()){...}
		ㄴ Demeter's Law
			- 메서드에서 생성한 객체의 메서드만 호출
			- 파라미터로 받은 객체의 메서드만 호출
			- 속성으로 참조하는 객체의 메서드만 호출
	- 정리
		ㄴ 기능의 구현을 외부에 감춤
		ㄴ 캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고(또는 최소화) 내부 구현을 변경할 수 있는 유연함
	- 캡슐화 연습
		ㄴ 데이터를 가져와서 비교하고, 그 비교한 값으로 데이터를 변경할 때는 통째로 캡슐화 시도
		ㄴ 데이터를 직접 가져와서 변경하는 부분은 로직을 내부적 캡슐화 하여 처리한다.
상속과 재사용
	- 상위 클래스의 기능을 재사용, 확장하는 방법
	- 단점
		- 상위 클래스 변경 어려움
			ㄴ 상위 클래스를 변경하면 모든 하위 클래스가 영향을 받아 비정상적으로 동작할 수 있음. 변경의 여파가 계층도를 따라 전파됨.
		- 클래스 증가
			ㄴ 새로운 조합이 생길 때 마다 하위 클래스가 증가한다.
		- 상속 오용
	- 단점을 커버하기 위해 조립(Composition)을 사용한다.
		ㄴ 여러 객체를 묶어서 더 복잡한 기능을 제공한다.
		ㄴ 보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요 시점에 생성/구함.
		ㄴ 상속하기에 앞서 조립으로 풀 수 없는지 검토
		ㄴ 진짜 하위 타입인 경우에만 상속 사용 - 단순히 그 기능이 필요하여 상속을 받는다면 반드시 논리적인 문제가 생긴다.
기능과 책임 분리
	- 기능 분해
		ㄴ 기능은 하위 기능으로 분해
	- 기능을 누가 제공할 것인가? (객체지향 설계의 기본 과정)
		- 기능은 곧 책임
			ㄴ 분리한 각 기능을 알맞게 분배
	- 책임 분배/분리 방법
		- 패턴 적용
			- 전형적인 역할 분리 - 역할 분리가 잘 되면 테스트도 용이해짐
				ㄴ 간단한 웹 - 컨트롤러, 서비스, DAO
				ㄴ 복잡한 도메인 - 엔티티, 밸류, 리포지토리, 도메인 서비스
				ㄴ AOP - Aspect(공통 기능)
				ㄴ GoF - 팩토리, 빌더, 전략, 템플릿 메서드, 프록시/데코레이터 등
		- 계산 기능 분리
		- 외부 연동 분리
		- 조건별 분기는 추상화
			- 연속적인 if-else는 추상화 고민
의존과 DI
	- 의존
		- 기능 구현을 위해 다른 구성 요소를 사용하는 것
			ㄴ ex) 객체생성, 메서드 호출, 데이터 사용
		- 의존은 변경이 전파될 가능성을 의미
			- 의존하는 대상이 바뀌면 바뀔 가능성이 높아짐
				ㄴ ex) 호출하는 메서드의 파라미터가 변경
				ㄴ ex) 호출하는 메서드가 발생할 수 있는 익셉션 타입이 추가
			- 순환 의존 > 변경 연쇄 전파 가능성 - 클래스, 패키지, 모듈 등 모둔 수준에서 순환 의존 없도록
	- 의존 주입 (Dependenct Injection)
		- 외부에서 의존 객체를 주입
			ㄴ 생성자나 메서드를 이용해서 주입